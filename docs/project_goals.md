# Цели проекта NetCom

## Философия проекта

NetCom - это универсальный сетевой стек, созданный с философией **полной абстракции от сетевой сложности**. Конечная цель - разработчик сетевого приложения **не должен думать** о сетевом стеке, авторизации, NAT, firewall или других низкоуровневых деталях.

**Ключевая философия:**
- Разработчик **знает только**: свой NetID/PeerId и целевой NetID/PeerId
- Разработчик **делает**: подключение и передачу данных
- Вся сложность **скрыта** за простым API

Проект вдохновлен Unix-философией разделения потоков данных и ошибок, аналогично stdout и stderr в Unix-системах, и стремится стать стандартом для построения распределенных приложений любого масштаба - от микросервисов до глобальных децентрализованных систем.

## Концепция NetID-Entity Architecture

### Двухуровневая идентификация

NetCom реализует инновационную двухуровневую модель идентификации:

- **NetID уровень** - высокоуровневые идентификаторы пользователей и сервисов (публичный ключ)
- **PeerId уровень** - низкоуровневые идентификаторы узлов в P2P сети

### Ключевые принципы

**NetID-PeerId Mapping:**
- **Общий случай**: Один NetID → множество PeerId (multi-node representation)
- **Упрощенный случай**: NetID = PeerId (для простых примеров и адресации)
- **Обязательная поддержка**: NetID → PeerId + Proof of Representation (PoR)

**Независимость узлов:**
- Узлы одного владельца функционируют автономно
- Взаимодействие между узлами по требованию
- Отсутствие обязательной синхронизации состояния
- Каждое устройство может иметь специализированные функции

### Терминология

- **NetID** - глобальный идентификатор пользователя или сервиса (публичный ключ)
- **Entity** - сущность (пользователь/сервис), представленная NetID
- **EntityNode** - узел, представляющий сущность в сети
- **PeerId** - идентификатор узла в libp2p (низкоуровневый)
- **Proof of Representation (PoR)** - криптографическое доказательство принадлежности узла к NetID

### Примеры архитектуры

**Пользовательская сущность (независимые устройства):**
```
NetID: Alice (публичный ключ)
├── Laptop (PeerId: QmAbc...) - автономный узел
├── Phone (PeerId: QmDef...) - автономный узел  
└── Tablet (PeerId: QmGhi...) - автономный узел
```

**Сервисная сущность (гибридный подход):**
```
NetID: funnycats.com (публичный ключ)
├── Server1 (PeerId: QmJkl...) - может использовать внутренние БД/очереди
├── Server2 (PeerId: QmMno...) - автономный узел
└── Server3 (PeerId: QmPqr...) - автономный узел
```

### Преимущества подхода

1. **Абстракция от физических узлов** - пользователи работают с сущностями, а не с IP-адресами
2. **Независимость устройств** - каждое устройство функционирует автономно
3. **Прямые соединения** - устройство-устройство без промежуточных серверов
4. **Гибкость архитектуры** - поддержка разных сценариев от простых до сложных
5. **Криптографические гарантии** - Proof of Representation для безопасности

## Основные цели

### 1. Простота использования
- **Высокоуровневый Python API** для быстрой разработки распределенных приложений
- **Интуитивный интерфейс** с минимальной конфигурацией
- **Асинхронные операции** как основа всего стека
- **Примеры использования** для быстрого старта
- **Автоматический discovery и соединение** - знаешь NetID/PeerId → автоматическое подключение
- **Сложность скрыта за простым API** - пользователь работает с абстракциями, а не с сетевыми деталями

### 2. Безопасность и аутентификация
- **Децентрализованная аутентификация** на основе открытых ключей
- **Proof of Entity Representation** для верификации принадлежности узлов
- **Встроенное шифрование** всех коммуникаций
- **Безопасные прямые соединения** между узлами
- **Защита от MITM-атак** через криптографическую верификацию

### 3. Прямые соединения и NAT-трансверсаль
- **Автоматическое установление соединений** между узлами за NAT
- **Поддержка различных сетевых конфигураций**
- **Надежная доставка сообщений** в сложных сетевых условиях
- **Минимальная зависимость от ретрансляторов**

### 4. Гибкие паттерны коммуникации
- **Запрос-ответ** для синхронных операций
- **Двусторонние потоки** для длительных сессий
- **Потоковая передача данных** любого размера
- **Одновременные множественные соединения**

### 5. Надежная обработка ошибок
- **Система двойных потоков XStream** для разделения данных и ошибок
- **Асинхронное уведомление об ошибках** без прерывания основного потока
- **Структурированные сообщения об ошибках** с контекстом
- **Грациозное восстановление** после сетевых сбоев

## Технические особенности

### Архитектура
- **Rust бэкенд** для производительности, безопасности и надежности
- **Python биндинги** через PyO3 для удобства разработки
- **Модульная структура**: protocols/, xnetwork/, pyxnetwork/
- **Асинхронная архитектура** на основе tokio (Rust) и asyncio (Python)

### Основные компоненты
- **XStream**: система двойных потоков для надежной передачи данных и ошибок
- **XAuth**: протокол децентрализованной аутентификации
- **NetworkNode**: высокоуровневый узел сети с полным управлением
- **Commander**: API для управления сетевыми операциями

### Целевое API

#### Connection методы
```python
# Подключение к сущности по NetID
connection = await node.connect_to_netid(alice_netid)

# Отправить запрос (request-response паттерн)
request_data = b'{"action": "get_user_profile", "user_id": "123"}'
response = await connection.request(request_data)

# Открыть байтовый поток (для файлов, медиа, бинарных данных)
bytes_stream = await connection.bytes_stream()
await bytes_stream.write(b"FILE_DATA_CHUNK")
received_data = await bytes_stream.read(4096)

# Открыть поток сообщений (для структурированных данных)
msg_stream = await connection.msg_stream()
await msg_stream.write(json.dumps({"type": "chat_message", "text": "Hello!"}).encode())
message = await msg_stream.read()
```

#### Discovery методы
```python
# Discover peer_id - поиск всех адресов подключения для узла
addresses = await node.discover_peer_id(target_peer_id)
# Возвращает: [Multiaddr("/ip4/192.168.1.1/tcp/4001/p2p/QmAbc..."), ...]

# Discover net_id - поиск всех узлов, представляющих сущность
active_nodes = await node.discover_netid(funnycats_netid)
# Возвращает: {PeerId("QmJkl..."): {"addresses": [...], "metadata": {...}}, ...}
```

#### Полный пример использования
```python
async def complete_service_interaction():
    # Создаем узел
    node = await Node.create()
    
    # 1. Discovery сущности
    service_nodes = await node.discover_netid(funnycats_netid)
    
    # 2. Подключение к сервису
    connection = await node.connect_to_netid(funnycats_netid)
    
    # 3. Различные паттерны коммуникации
    # Запрос-ответ для метаданных
    metadata = await connection.request(b'{"action": "get_service_info"}')
    
    # Байтовый поток для загрузки контента
    media_stream = await connection.bytes_stream()
    await media_stream.write(b"REQUEST_MEDIA_STREAM")
    
    # Поток сообщений для чата
    chat_stream = await connection.msg_stream()
    await chat_stream.write(json.dumps({"message": "Hello service!"}).encode())
    
    return connection
```

## Отличия от традиционных подходов

### Сравнение с DNS и HTTP/HTTPS

**Аналогия с DNS, но лучше:**
| Аспект | DNS | NetCom |
|--------|-----|--------|
| **Архитектура** | Централизованная | Децентрализованная + криптографическая |
| **Безопасность** | Доверие к CA | Криптографические гарантии |
| **Discovery** | Текстовое имя → IP-адреса | NetID/PeerId → адреса + криптографические доказательства |
| **Гибкость** | Только клиент-сервер | Клиент-клиент, клиент-сервер, сервер-сервер |

**Сравнение с HTTP/HTTPS:**
| Аспект | HTTP/HTTPS | NetCom |
|--------|------------|--------|
| **Архитектура** | Клиент-сервер | P2P с NetID |
| **Аутентификация** | Централизованная | Децентрализованная |
| **Паттерны** | Request-response | Множественные паттерны |
| **Обработка ошибок** | Коды статуса | Асинхронные сообщения |
| **Соединения** | Временные | Долгоживущие |

### Фундаментальные преимущества NetCom

1. **Прямые P2P соединения** - клиент-клиент, клиент-сервер, сервер-сервер
2. **Децентрализованный discovery** с криптографическими гарантиями
3. **Простота использования** - знаешь NetID/PeerId → автоматическое подключение
4. **Прямой обмен между устройствами** без облачных серверов
5. **Гибкость архитектуры** - от простых до сложных сценариев
6. **Встроенная безопасность** на уровне протокола

### Ключевые сценарии использования

**Прямой обмен между устройствами пользователя:**
- Alice передает файл напрямую Bob (без облачного сервиса)
- Устройства IoT общаются напрямую
- Децентрализованные социальные сети (пользователь-пользователь)

**Подключение к интернет-сервисам:**
- Пользователь подключается к публичным сервисам
- Сервисы могут использовать внутренние централизованные компоненты
- Гибридные развертывания (локальные + облачные узлы)

### Вдохновение Unix-философией
Как в Unix-системах stdout и stderr разделены для лучшего управления выводом, в NetCom основной поток и поток ошибок разделены для:
- Независимой обработки данных и ошибок
- Асинхронного уведомления о проблемах
- Сохранения контекста при сбоях
- Улучшенной диагностики проблем

## Примеры использования

### Сценарий 1: Мульти-устройственный пользователь
```python
# Alice имеет ноутбук, телефон и планшет
alice_netid = NetID.generate()

# Каждое устройство создает свой узел, но представляет Alice
laptop_node = await Node.create(netid=alice_netid)
phone_node = await Node.create(netid=alice_netid)
tablet_node = await Node.create(netid=alice_netid)

# Bob подключается к Alice (любому из её узлов)
bob_node = await Node.create()
connection = await bob_node.connect_to_netid(alice_netid)

# Использование различных паттернов коммуникации
# Запрос-ответ для получения статуса
status = await connection.request(b'{"action": "get_status"}')

# Байтовый поток для передачи файлов
file_stream = await connection.bytes_stream()
await file_stream.write(b"FILE_CONTENT")

# Поток сообщений для чата
chat_stream = await connection.msg_stream()
await chat_stream.write(json.dumps({"message": "Hi Alice!"}).encode())
```

### Сценарий 2: Публичный сервис с кластером узлов
```python
# Сервис funnycats.com развернут на 3 серверах
funnycats_netid = NetID.from_domain("funnycats.com")

# Каждый сервер запускает узел
for server in servers:
    node = await Node.create(
        netid=funnycats_netid,
        role=NodeRole.SERVER
    )

# Пользователь подключается к сервису
user_node = await Node.create()
service_conn = await user_node.connect_to_netid(funnycats_netid)

# Discovery всех активных узлов сервиса
active_nodes = await user_node.discover_netid(funnycats_netid)
print(f"Активные узлы сервиса: {list(active_nodes.keys())}")

# Использование сервиса
# Запрос контента
content_request = b'{"action": "get_cat_video", "id": "123"}'
video_data = await service_conn.request(content_request)

# Поток для живого чата поддержки
support_stream = await service_conn.msg_stream()
await support_stream.write(json.dumps({"question": "How to use?"}).encode())
```

### Сценарий 3: Гибридное развертывание
```python
# Компания с локальными серверами и облачными узлами
company_netid = NetID.from_domain("mycompany.com")

# Локальные узлы
local_node = await Node.create(netid=company_netid, local=True)

# Облачные узлы  
cloud_node = await Node.create(netid=company_netid, cloud=True)

# Клиент подключается к ближайшему доступному узлу
client_node = await Node.create()
connection = await client_node.connect_to_netid(company_netid)

# Discovery показывает все доступные узлы
all_nodes = await client_node.discover_netid(company_netid)
print(f"Доступные узлы компании: {len(all_nodes)}")

# Автоматический failover при проблемах
try:
    response = await connection.request(b"critical_operation")
except ConnectionError:
    # Автоматическое переподключение к другому узлу
    connection = await client_node.connect_to_netid(company_netid)
    response = await connection.request(b"critical_operation")
```

## Целевые сценарии использования

### 1. Микросервисные архитектуры
- **Внутренняя связность кластера** - микросервисы общаются через NetCom
- **Глобальная сеть микросервисов** - распределенные сервисы по всему миру
- **Service mesh альтернатива** - без зависимости от централизованных решений
- **Внутренние RPC коммуникации** - с децентрализованной аутентификацией

### 2. Пользовательский суверенитет
- **Контроль над устройствами** - пользователь управляет всеми своими устройствами напрямую
- **Независимость от крупных компаний** - нет зависимости от Google, Apple, Amazon
- **Прямые соединения устройство-устройство** - без облачных посредников
- **Децентрализованные социальные сети** - пользователь-пользователь взаимодействие

### 3. Современные клиент-серверные решения
- **Альтернатива традиционному RPC** - с лучшей аутентификацией и безопасностью
- **Облачные сервисы нового поколения** - с децентрализованной идентификацией
- **Гибридные развертывания** - сочетание локальных и облачных узлов
- **IoT сети устройств** - прямое взаимодействие без центральных серверов

### 4. Мощные децентрализованные сервисы
- **Независимость от DNS/SSL провайдеров** - криптографические гарантии вместо CA
- **Устойчивость к цензуре** - сервисы работают без центрального контроля
- **Глобальная доступность** - без географических ограничений
- **Распределенные базы данных** - с P2P репликацией

### 5. Инфраструктурные решения
- **Сетевые прокси и туннели** - с децентрализованным управлением
- **Системы мониторинга и логирования** - распределенные по узлам
- **Распределенные очереди сообщений** - без центрального брокера
- **P2P файлообменные системы** - прямое устройство-устройство передача

## Идеальный Developer Experience

### Ключевая философия
Разработчик **не думает** о сетевом стеке, авторизации, NAT, firewall или других низкоуровневых деталях. Разработчик **знает только** свой NetID/PeerId и целевой NetID/PeerId, и **делает** подключение и передачу данных.

### Пример идеального workflow
```python
# Разработчик знает только это:
my_netid = NetID.generate()
target_netid = NetID.from_string("alice.netcom")

# И делает только это:
node = await Node.create(netid=my_netid)
connection = await node.connect_to_netid(target_netid)

# Затем передает данные любым способом:
await connection.request(b"ping")
stream = await connection.bytes_stream()
await stream.write(b"file_content")
```

### Что скрыто от разработчика
- **Discovery механизмы** - DHT, mDNS, специализированные сервисы
- **NAT traversal и connectivity** - автоматический выбор оптимального пути
- **Аутентификация и безопасность** - Proof of Representation, шифрование
- **Обработка ошибок и восстановление** - автоматическое восстановление соединений
- **Сетевые протоколы и транспорт** - адаптация к сетевым условиям

### Преимущества для разработчика
- **Фокус на бизнес-логике** - а не на сетевых деталях
- **Быстрая разработка** - минимальная конфигурация и настройка
- **Надежность** - встроенные механизмы отказоустойчивости
- **Безопасность** - криптографические гарантии по умолчанию
- **Масштабируемость** - от одного устройства до глобальной сети

## Будущее развитие

Проект NetCom стремится стать стандартом для построения современных распределенных приложений, предоставляя:
- Простой, но мощный API для разработчиков
- Надежную основу для критически важных систем
- Гибкость для адаптации к различным сценариям использования
- Сообщество разработчиков и экосистему инструментов

Конечная цель - создать сетевой стек, который органично заменяет устаревшие HTTP-подходы и предоставляет все необходимые инструменты для построения современных распределенных систем с поддержкой NetID-ориентированной архитектуры.
