# XStream - Advanced P2P Stream Protocol

XStream - —ç—Ç–æ –ø—Ä–æ—Ç–æ–∫–æ–ª —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã—Ö –ø–æ—Ç–æ–∫–æ–≤ –¥–ª—è —É–¥–æ–±–Ω–æ–π —Å–µ—Ç–µ–≤–æ–π –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–∏ –≤ —Å—Ç–∏–ª–µ RPC —Å –Ω–∞–¥–µ–∂–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫. –û—Å–Ω–æ–≤–Ω–æ–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ - —É–¥–æ–±–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –∑–∞ —Å—á–µ—Ç —Å–æ–∑–¥–∞–Ω–∏—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞ –æ—à–∏–±–æ–∫, –∫–æ—Ç–æ—Ä—ã–π –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç —Å–≤–æ–µ–≤—Ä–µ–º–µ–Ω–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ—à–∏–±–æ–∫, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–º.

## üöÄ Key Features

- **–ù–∞–¥–µ–∂–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫** - –æ—Ç–¥–µ–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫ –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –æ—à–∏–±–æ–∫
- **–ú–µ—Ö–∞–Ω–∏–∑–º –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏–π** - –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ –≤—Ö–æ–¥—è—â–∏–º–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è–º–∏
- **–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏** - –Ω–µ–±–ª–æ–∫–∏—Ä—É—é—â–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —á—Ç–µ–Ω–∏—è/–∑–∞–ø–∏—Å–∏
- **–ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –¥–æ—Å—Ç–∞–≤–∫–∞** - –∫–æ–Ω—Ç—Ä–æ–ª—å —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ—Ç–æ–∫–æ–≤
- **–ì–∏–±–∫–∏–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è** - RPC, streaming, messaging

## üìã Use Cases

–ò—Å–ø–æ–ª—å–∑—É—è XStream –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ä–∞–∑–ª–∏—á–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è:

- **–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å-–æ—Ç–≤–µ—Ç** - –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π RPC –ø–∞—Ç—Ç–µ—Ä–Ω
- **–û–¥–Ω–æ –∏–ª–∏ –¥–≤—É—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π –æ–±–º–µ–Ω –ø–æ—Ç–æ–∫–æ–º –±–∞–π—Ç–æ–≤** - —Ñ–∞–π–ª–æ–≤—ã–π –æ–±–º–µ–Ω, —Å—Ç—Ä–∏–º–∏–Ω–≥
- **–û–¥–Ω–æ –∏–ª–∏ –¥–≤—É—Å—Ç–æ—Ä–æ–Ω–Ω–∏–π –æ–±–º–µ–Ω —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏** - —á–∞—Ç, —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è

## üèóÔ∏è Architecture

XStream —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ –¥–≤—É—Ö –ø–æ—Ç–æ–∫–æ–≤ `libp2p::Stream`:
- **–û—Å–Ω–æ–≤–Ω–æ–π –ø–æ—Ç–æ–∫** - –¥–≤—É–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –¥–ª—è –¥–∞–Ω–Ω—ã—Ö
- **–ü–æ—Ç–æ–∫ –æ—à–∏–±–æ–∫** - –æ–¥–Ω–æ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞ –∫ –∫–ª–∏–µ–Ω—Ç—É

## ‚ö° Quick Start

### Installation

–î–æ–±–∞–≤—å—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –≤ –≤–∞—à `Cargo.toml`:

```toml
[dependencies]
xstream = { path = "protocols/xstream" }
```

### Basic Usage

```rust
use xstream::behaviour::XStreamNetworkBehaviour;
use libp2p::{Swarm, swarm::SwarmBuilder, identity, PeerId};
use tokio::sync::oneshot;

#[tokio::main]
async fn main() {
    // –°–æ–∑–¥–∞–Ω–∏–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ —É–∑–ª–∞
    let local_key = identity::Keypair::generate_ed25519();
    let local_peer_id = PeerId::from(local_key.public());
    
    // –°–æ–∑–¥–∞–Ω–∏–µ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞
    let transport = libp2p::development_transport(local_key).await.unwrap();
    
    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–≤–µ–¥–µ–Ω–∏—è XStream
    let behaviour = XStreamNetworkBehaviour::new();
    
    // –°–æ–∑–¥–∞–Ω–∏–µ Swarm
    let mut swarm = SwarmBuilder::with_tokio_executor(transport, behaviour, local_peer_id).build();
    
    // –ó–∞–ø—É—Å–∫ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è
    swarm.listen_on("/memory/0".parse().unwrap()).unwrap();
    
    println!("XStream node started with peer ID: {}", local_peer_id);
}
```

### Opening a Stream and Data Exchange

```rust
use xstream::behaviour::XStreamNetworkBehaviour;
use xstream::xstream::XStream;
use libp2p::{PeerId, Multiaddr};
use tokio::sync::oneshot;

async fn open_stream_and_exchange_data(
    swarm: &mut Swarm<XStreamNetworkBehaviour>,
    peer_id: PeerId
) -> Result<(), Box<dyn std::error::Error>> {
    // –û—Ç–∫—Ä—ã—Ç–∏–µ –ø–æ—Ç–æ–∫–∞
    let (response_sender, response_receiver) = oneshot::channel();
    swarm.behaviour_mut().open_stream(peer_id, response_sender).await;
    
    // –ü–æ–ª—É—á–µ–Ω–∏–µ XStream
    let xstream = response_receiver.await??;
    
    // –ó–∞–ø–∏—Å—å –¥–∞–Ω–Ω—ã—Ö
    let data = b"Hello, XStream!";
    xstream.write_all(data.to_vec()).await?;
    xstream.flush().await?;
    
    // –ß—Ç–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ–º read_to_end –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã)
    let response = xstream.read_to_end().await?;
    
    println!("Received: {}", String::from_utf8_lossy(&response));
    
    // –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ—Ç–æ–∫–∞
    xstream.close().await?;
    
    Ok(())
}
```

## üîß API Reference

### –û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç–æ–¥—ã —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω—ã–º–∏:

```rust
// –ß—Ç–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
async fn read(&self, buf: &mut [u8]) -> Result<usize, XStreamError>;
async fn read_exact(&self, buf: &mut [u8]) -> Result<(), XStreamError>;
async fn read_to_end(&self) -> Result<Vec<u8>, XStreamError>;

// –ó–∞–ø–∏—Å—å –¥–∞–Ω–Ω—ã—Ö
async fn write(&self, buf: &[u8]) -> Result<usize, XStreamError>;
async fn write_all(&self, buf: &[u8]) -> Result<(), XStreamError>;
async fn flush(&self) -> Result<(), XStreamError>;

// –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–æ–º
async fn write_eof(&self) -> Result<(), XStreamError>;
async fn close(&self) -> Result<(), XStreamError>;
```

### –†–∞–±–æ—Ç–∞ —Å –æ—à–∏–±–∫–∞–º–∏

```rust
// –ó–∞–ø–∏—Å—å –æ—à–∏–±–∫–∏
async fn error_write(&self, error_data: &[u8], with_data_flush: bool) -> Result<(), XStreamError>;

// –ß—Ç–µ–Ω–∏–µ –æ—à–∏–±–∫–∏
async fn error_read(&self) -> Result<Vec<u8>, XStreamError>;
```

**–õ–æ–≥–∏–∫–∞ —Ä–∞–±–æ—Ç—ã –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–Ω–æ–π –æ—à–∏–±–∫–µ:**
- –ü–æ–ª—É—á–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ –∫—ç—à–µ
- –ü–æ–≤—Ç–æ—Ä–Ω—ã–π –≤—ã–∑–æ–≤ `error_read()` –≤–µ—Ä–Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—É—é –æ—à–∏–±–∫—É
- –ü–æ –ø–æ—Ç–æ–∫—É –æ—à–∏–±–æ–∫ –º–æ–∂–µ—Ç –ø—Ä–∏–π—Ç–∏ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –±–ª–æ–∫ –¥–∞–Ω–Ω—ã—Ö, –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—â–∏–π—Å—è EOF
- –ù–µ–ª—å–∑—è –∑–∞–ø–∏—Å–∞—Ç—å –æ—à–∏–±–∫—É –¥–≤–∞–∂–¥—ã

## üéØ Advanced Features

### –ú–µ—Ö–∞–Ω–∏–∑–º –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏–π –æ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è—Ö

XStream –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –≥–∏–±–∫–∏–π –º–µ—Ö–∞–Ω–∏–∑–º –∫–æ–Ω—Ç—Ä–æ–ª—è –Ω–∞–¥ –≤—Ö–æ–¥—è—â–∏–º–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è–º–∏:

```rust
use xstream::events::{IncomingConnectionApprovePolicy, InboundUpgradeDecision};

// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–¥–æ–±—Ä–µ–Ω–∏–µ –≤—Å–µ—Ö —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
let behaviour = XStreamNetworkBehaviour::new(); // AutoApprove –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

// –ò–ª–∏ —Ä—É—á–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ —Å–æ–±—ã—Ç–∏—è
let behaviour = XStreamNetworkBehaviour::new_with_policy(
    IncomingConnectionApprovePolicy::ApproveViaEvent
);

// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏–π –∑–∞–ø—Ä–æ—Å–æ–≤
match swarm.next().await {
    Some(SwarmEvent::Behaviour(XStreamEvent::InboundUpgradeRequest {
        peer_id,
        connection_id,
        response_sender,
    })) => {
        // –ü—Ä–∏–Ω—è—Ç–∏–µ —Ä–µ—à–µ–Ω–∏—è
        let decision = if should_accept_connection(&peer_id) {
            InboundUpgradeDecision::Approved
        } else {
            InboundUpgradeDecision::Rejected("Peer not allowed".to_string())
        };
        
        response_sender.send(decision).ok();
    }
    // ... –¥—Ä—É–≥–∏–µ —Å–æ–±—ã—Ç–∏—è
}
```

### –ü–æ–ª–∏—Ç–∏–∫–∏ –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏–π

- **`AutoApprove`** - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–¥–æ–±—Ä–µ–Ω–∏–µ –≤—Å–µ—Ö –≤—Ö–æ–¥—è—â–∏—Ö –∞–ø–≥—Ä–µ–π–¥–æ–≤
- **`ApproveViaEvent`** - –ø–µ—Ä–µ–¥–∞—á–∞ —Å–æ–±—ã—Ç–∏—è –≤ Swarm –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏

## üîÑ State Management

–°–∞–º–∞—è —Å–ª–æ–∂–Ω–∞—è –∏ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–∞—è —á–∞—Å—Ç—å XStream:

- –û–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è –∑–∞–ø–∏—Å–∏ –∏–ª–∏ —á—Ç–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö (–≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç—Å—è –ø—Ä–∏–º–µ–Ω—è–µ–º—ã–º `Mutex`)
- –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è –ø–æ–ª—É—á–µ–Ω–∏–µ –æ—à–∏–±–æ–∫
- –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ –≤–æ–∑–Ω–∏–∫–∞–µ—Ç –≤ –º–æ–º–µ–Ω—Ç –±–ª–æ–∫–∏—Ä—É—é—â–µ–π –æ–ø–µ—Ä–∞—Ü–∏–∏ —á—Ç–µ–Ω–∏—è/–∑–∞–ø–∏—Å–∏, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –æ—à–∏–±–∫–∞ –∏ –≤—ã—Å—Ç–∞–≤–ª—è—é—Ç—Å—è –Ω—É–∂–Ω—ã–µ —Å—Ç–∞—Ç—É—Å—ã

## üß™ Testing

–ü—Ä–æ–µ–∫—Ç –≤–∫–ª—é—á–∞–µ—Ç 170+ —Ç–µ—Å—Ç–æ–≤, –ø–æ–∫—Ä—ã–≤–∞—é—â–∏—Ö –≤—Å–µ –∞—Å–ø–µ–∫—Ç—ã —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏:

```bash
cd protocols/xstream
cargo test

# –ó–∞–ø—É—Å–∫ —Ç–æ–ª—å–∫–æ —Ç–µ—Å—Ç–æ–≤ –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏–π
cargo test inbound_upgrade
```

## üìö Examples

### –ë–∞–∑–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

–ü–æ–ª–Ω—ã–π —Ä–∞–±–æ—á–∏–π –ø—Ä–∏–º–µ—Ä —Å QUIC —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–æ–º –∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π swarm loop:

```bash
cargo run --example basic_usage
```

```rust
use xstream::behaviour::XStreamNetworkBehaviour;
use xstream::events::XStreamEvent;
use libp2p::{identity, quic, Swarm, SwarmEvent, Multiaddr, PeerId};
use tokio::sync::{oneshot, mpsc};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // –°–æ–∑–¥–∞–Ω–∏–µ –¥–≤—É—Ö —É–∑–ª–æ–≤ —Å QUIC —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–æ–º
    let (mut client_swarm, client_peer_id) = create_quic_swarm().await?;
    let (mut server_swarm, server_peer_id) = create_quic_swarm().await?;
    
    // –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞ –∏ –∫–ª–∏–µ–Ω—Ç–∞ –≤ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –∑–∞–¥–∞—á–∞—Ö
    // –ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –≤ examples/basic_usage.rs
}
```

### –ú–µ—Ö–∞–Ω–∏–∑–º –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏–π –æ –≤—Ö–æ–¥—è—â–∏—Ö –ø–æ—Ç–æ–∫–∞—Ö

–ü—Ä–∏–º–µ—Ä —Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–µ–π –ø–∏—Ä–æ–≤ –∏ –æ—Ç–ø—Ä–∞–≤–∫–æ–π –æ—à–∏–±–æ–∫ –ø—Ä–∏ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–∏:

```bash
cargo run --example inbound_decision
```

```rust
use xstream::behaviour::XStreamNetworkBehaviour;
use xstream::events::{XStreamEvent, InboundUpgradeDecision, IncomingConnectionApprovePolicy};
use libp2p::{identity, quic, Swarm, SwarmEvent, PeerId};
use std::collections::HashSet;

// –í–∞–∂–Ω–æ: –¥–ª—è —Ä–∞–±–æ—Ç—ã –º–µ—Ö–∞–Ω–∏–∑–º–∞ –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏–π –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ–ª–∏—Ç–∏–∫—É ApproveViaEvent
let swarm = libp2p::SwarmBuilder::with_existing_identity(keypair)
    .with_tokio()
    .with_other_transport(|_key| quic_transport)
    .expect("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å QUIC —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç")
    .with_behaviour(|_key| {
        XStreamNetworkBehaviour::new_with_policy(
            IncomingConnectionApprovePolicy::ApproveViaEvent
        )
    })
    .expect("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å XStream –ø–æ–≤–µ–¥–µ–Ω–∏–µ")
    .build();

async fn handle_inbound_upgrade(
    swarm: &mut Swarm<XStreamNetworkBehaviour>,
    allowed_peers: &HashSet<PeerId>
) {
    while let Some(event) = swarm.next().await {
        match event {
            SwarmEvent::Behaviour(XStreamEvent::InboundUpgradeRequest {
                peer_id,
                connection_id,
                response_sender,
            }) => {
                // –ú–µ—Ö–∞–Ω–∏–∑–º –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏—è
                let decision = if allowed_peers.contains(&peer_id) {
                    InboundUpgradeDecision::Approved
                } else {
                    InboundUpgradeDecision::Rejected("Peer not authorized".to_string())
                };
                
                response_sender.send(decision).ok();
            }
            _ => {}
        }
    }
}
```

**–í–∞–∂–Ω–æ:** –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é XStream –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø–æ–ª–∏—Ç–∏–∫—É `AutoApprove`, –∫–æ—Ç–æ—Ä–∞—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–¥–æ–±—Ä—è–µ—Ç –≤—Å–µ –≤—Ö–æ–¥—è—â–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è. –î–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –º–µ—Ö–∞–Ω–∏–∑–º–∞ –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏–π –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —è–≤–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–ª–∏—Ç–∏–∫—É `ApproveViaEvent` –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–≤–µ–¥–µ–Ω–∏—è.

### –ü—Ä–æ—Å—Ç–æ–π RPC —Å–µ—Ä–≤–µ—Ä

```rust
use xstream::{XStreamNetworkBehaviour, XStream};
use libp2p::{Swarm, SwarmEvent};

async fn rpc_server(mut swarm: Swarm<XStreamNetworkBehaviour>) {
    while let Some(event) = swarm.next().await {
        match event {
            SwarmEvent::Behaviour(XStreamEvent::IncomingStream { stream }) => {
                tokio::spawn(async move {
                    handle_rpc_request(stream).await;
                });
            }
            _ => {}
        }
    }
}

async fn handle_rpc_request(mut stream: XStream) -> Result<(), Box<dyn std::error::Error>> {
    // –ß—Ç–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞
    let request = stream.read_to_end().await?;
    
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞
    let response = process_request(&request).await?;
    
    // –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞
    stream.write_all(&response).await?;
    stream.flush().await?;
    
    Ok(())
}
```

### –ü–æ—Ç–æ–∫–æ–≤–∞—è –ø–µ—Ä–µ–¥–∞—á–∞ —Ñ–∞–π–ª–æ–≤

```rust
async fn stream_file(mut stream: XStream, file_path: &str) -> Result<(), Box<dyn std::error::Error>> {
    let file_data = std::fs::read(file_path)?;
    
    // –û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–∞–π–ª–∞ —á–∞–Ω–∫–∞–º–∏
    for chunk in file_data.chunks(1024) {
        stream.write_all(chunk).await?;
    }
    
    stream.write_eof().await?;
    Ok(())
}
```

## üîó Integration

XStream –ª–µ–≥–∫–æ –∏–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ—Ç—Å—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ libp2p –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è–º–∏:

```rust
use libp2p::swarm::NetworkBehaviour;

#[derive(NetworkBehaviour)]
struct MyAppBehaviour {
    xstream: XStreamNetworkBehaviour,
    identify: libp2p::identify::Behaviour,
    // ... –¥—Ä—É–≥–∏–µ –ø–æ–≤–µ–¥–µ–Ω–∏—è
}
```

## üìä Performance

- **–ù–∏–∑–∫–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞** - –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
- **–í—ã—Å–æ–∫–∞—è –ø—Ä–æ–ø—É—Å–∫–Ω–∞—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å** - —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è
- **–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –Ω–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã** - –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

## ü§ù Contributing

–ú—ã –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–µ–º –≤–∫–ª–∞–¥ –≤ —Ä–∞–∑–≤–∏—Ç–∏–µ XStream! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π –ø—É–ª-—Ä–µ–∫–≤–µ—Å—Ç–∞.

## üìÑ License

XStream —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è–µ—Ç—Å—è –ø–æ–¥ –ª–∏—Ü–µ–Ω–∑–∏–µ–π –ø—Ä–æ–µ–∫—Ç–∞ NetCom.

---

**XStream** - –Ω–∞–¥–µ–∂–Ω–∞—è P2P –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏—è —Å –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫ –∏ –≥–∏–±–∫–∏–º –∫–æ–Ω—Ç—Ä–æ–ª–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π.
